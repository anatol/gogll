//  Copyright 2019 Marius Ackerman
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// Package slots generates a Go parser slots package
package slots

import (
	"bytes"
	"text/template"

	"github.com/goccmack/gogll/v3/ast"
	"github.com/goccmack/gogll/v3/frstflw"
	"github.com/goccmack/gogll/v3/gslot"
	"github.com/goccmack/goutil/ioutil"
)

func Gen(slotFile string, g *ast.GoGLL, gs *gslot.GSlot, ff *frstflw.FF) {
	tmpl, err := template.New("Slot").Parse(slotTmpl)
	if err != nil {
		panic(err)
	}
	buf, data := new(bytes.Buffer), getData(g, gs, ff)
	if err = tmpl.Execute(buf, data); err != nil {
		panic(err)
	}
	if err := ioutil.WriteFile(slotFile, buf.Bytes()); err != nil {
		panic(err)
	}
}

type Data struct {
	Package string
	Slots   []*SlotData
	Alts    []*AltData
}

type AltData struct {
	NT     string
	Labels string
}

type SlotData struct {
	Label   string
	NT      string
	Alt     int
	Pos     int
	Symbols []string
}

func getData(g *ast.GoGLL, gs *gslot.GSlot, ff *frstflw.FF) *Data {
	return &Data{
		Package: g.Package.GetString(),
		Slots:   getSlotData(gs),
		Alts:    getAltData(g, gs, ff),
	}
}

func getAltData(g *ast.GoGLL, gs *gslot.GSlot, ff *frstflw.FF) (data []*AltData) {
	for _, r := range g.SyntaxRules {
		d := &AltData{r.Head.ID(), getLabelList(r, g, gs, ff)}
		data = append(data, d)
	}
	return
}

func getLabelList(rule *ast.SyntaxRule, g *ast.GoGLL, gs *gslot.GSlot, ff *frstflw.FF) string {
	buf := new(bytes.Buffer)
	for i := range rule.Alternates {
		if i > 0 {
			buf.WriteString(",")
		}
		buf.WriteString(gslot.NewLabel(rule.Head.ID(), i, 0, gs, ff).Label())
	}
	return buf.String()
}

func getSlotData(gs *gslot.GSlot) (data []*SlotData) {
	for _, s := range gs.Slots() {
		d := &SlotData{
			Label:   s.Label(),
			NT:      s.Head,
			Alt:     s.Alternate,
			Pos:     s.Pos,
			Symbols: s.Symbols().GoStrings(),
		}
		data = append(data, d)
	}
	return
}

const slotTmpl = `
// Package slot is generated by gogll. Do not edit. 
package slot

import(
	"bytes"
	"fmt"
	
	"{{.Package}}/parser/symbols"
)

type Label int

const({{range $i, $l := .Slots}}
	{{$l.Label}}{{if not $i}} Label = iota{{end}}{{end}}
)

type Slot struct {
	NT      symbols.NT
	Alt     int
	Pos     int
	Symbols symbols.Symbols
	Label 	Label
}

type Index struct {
	NT      symbols.NT
	Alt     int
	Pos     int
}

func GetAlternates(nt symbols.NT) []Label {
	alts, exist := alternates[nt]
	if !exist {
		panic(fmt.Sprintf("Invalid NT %s", nt))
	}
	return alts
}

func GetLabel(nt symbols.NT, alt, pos int) Label {
	l, exist := slotIndex[Index{nt,alt,pos}]
	if exist {
		return l
	}
	panic(fmt.Sprintf("Error: no slot label for NT=%s, alt=%d, pos=%d", nt, alt, pos))
}

func (l Label) EoR() bool {
	return l.Slot().EoR()
}

func (l Label) Head() symbols.NT {
	return l.Slot().NT
}

func (l Label) Index() Index {
	s := l.Slot()
	return Index{s.NT, s.Alt, s.Pos}
}

func (l Label) Alternate() int {
	return l.Slot().Alt
}

func (l Label) Pos() int {
	return l.Slot().Pos
}

func (l Label) Slot() *Slot {
	s, exist := slots[l]
	if !exist {
		panic(fmt.Sprintf("Invalid slot label %d", l))
	}
	return s
}

func (l Label) String() string {
	return l.Slot().String()
}

func (l Label) Symbols() symbols.Symbols {
	return l.Slot().Symbols
}

func (s *Slot) EoR() bool {
	return s.Pos >= len(s.Symbols)
}

func (s *Slot) String() string {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "%s : ", s.NT)
	for i, sym := range s.Symbols {
		if i == s.Pos {
			fmt.Fprintf(buf, "∙")
		}
		fmt.Fprintf(buf, "%s ", sym)
	}
	if s.Pos >= len(s.Symbols) {
		fmt.Fprintf(buf, "∙")
	}
	return buf.String()
}

var slots = map[Label]*Slot{ {{range $i, $s := .Slots}}
	{{$s.Label}}: {
		symbols.NT_{{$s.NT}}, {{$s.Alt}}, {{$s.Pos}}, 
		symbols.Symbols{ {{range $sym := $s.Symbols}} 
			symbols.{{$sym}},{{end}}
		}, 
		{{$s.Label}}, 
	},{{end}}
}

var slotIndex = map[Index]Label { {{range $i, $s := .Slots}}
	Index{ symbols.NT_{{$s.NT}},{{$s.Alt}},{{$s.Pos}} }: {{$s.Label}},{{end}}
}

var alternates = map[symbols.NT][]Label{ {{range $i, $a := .Alts}}
	symbols.NT_{{$a.NT}}:[]Label{ {{$a.Labels}} },{{end}}
}

`
