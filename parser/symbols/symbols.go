
// Package symbols is generated by gogll. Do not edit.
package symbols

import(
	"bytes"
	"fmt"
)

type Symbol interface{
	isSymbol()
	IsNonTerminal() bool
	String() string
}

func (NT) isSymbol() {}
func (T) isSymbol() {}

// NT is the type of non-terminals symbols
type NT int
const( 
	NT_GoGLL NT = iota
	NT_LexAlternates 
	NT_LexBracket 
	NT_LexGroup 
	NT_LexOneOrMore 
	NT_LexOptional 
	NT_LexRule 
	NT_LexSymbol 
	NT_LexZeroOrMore 
	NT_Package 
	NT_PlusOrMinUnicodeSet 
	NT_RegExp 
	NT_Rule 
	NT_Rules 
	NT_SyntaxAlternate 
	NT_SyntaxAlternates 
	NT_SyntaxRule 
	NT_SyntaxSymbol 
	NT_SyntaxSymbols 
	NT_UnicodeCategory 
	NT_UnicodeClass 
	NT_UnicodeProperty 
	NT_UnicodeSet 
	NT_UnicodeSetSpec 
	NT_UnicodeSetSpecs 
	NT_UnicodeSpecList 
)

// T is the type of terminals symbols
type T int
const( 
	T_0 T = iota // ! 
	T_1  // '[ 
	T_2  // ( 
	T_3  // ) 
	T_4  // - 
	T_5  // . 
	T_6  // : 
	T_7  // ; 
	T_8  // < 
	T_9  // > 
	T_10  // [ 
	T_11  // \\p{ASCII_Hex_Digit} 
	T_12  // \\p{Bidi_Control} 
	T_13  // \\p{Cc} 
	T_14  // \\p{Cf} 
	T_15  // \\p{Co} 
	T_16  // \\p{Cs} 
	T_17  // \\p{C} 
	T_18  // \\p{Dash} 
	T_19  // \\p{Deprecated} 
	T_20  // \\p{Diacritic} 
	T_21  // \\p{Digit} 
	T_22  // \\p{Extender} 
	T_23  // \\p{Hex_Digit} 
	T_24  // \\p{Hyphen} 
	T_25  // \\p{IDS_Binary_Operator} 
	T_26  // \\p{IDS_Trinary_Operator} 
	T_27  // \\p{Ideographic} 
	T_28  // \\p{Join_Control} 
	T_29  // \\p{Letter} 
	T_30  // \\p{Ll} 
	T_31  // \\p{Lm} 
	T_32  // \\p{Logical_Order_Exception} 
	T_33  // \\p{Lower} 
	T_34  // \\p{Lo} 
	T_35  // \\p{Lt} 
	T_36  // \\p{Lu} 
	T_37  // \\p{L} 
	T_38  // \\p{Mark} 
	T_39  // \\p{Mc} 
	T_40  // \\p{Me} 
	T_41  // \\p{Mn} 
	T_42  // \\p{M} 
	T_43  // \\p{Nd} 
	T_44  // \\p{Nl} 
	T_45  // \\p{Noncharacter_Code_Point} 
	T_46  // \\p{No} 
	T_47  // \\p{Number} 
	T_48  // \\p{N} 
	T_49  // \\p{Other_Alphabetic} 
	T_50  // \\p{Other_Default_Ignorable_Code_Point} 
	T_51  // \\p{Other_Grapheme_Extend} 
	T_52  // \\p{Other_ID_Continue} 
	T_53  // \\p{Other_ID_Start} 
	T_54  // \\p{Other_Lowercase} 
	T_55  // \\p{Other_Math} 
	T_56  // \\p{Other_Uppercase} 
	T_57  // \\p{Other} 
	T_58  // \\p{Pattern_Syntax} 
	T_59  // \\p{Pattern_White_Space} 
	T_60  // \\p{Pc} 
	T_61  // \\p{Pd} 
	T_62  // \\p{Pe} 
	T_63  // \\p{Pf} 
	T_64  // \\p{Pi} 
	T_65  // \\p{Po} 
	T_66  // \\p{Prepended_Concatenation_Mark} 
	T_67  // \\p{Ps} 
	T_68  // \\p{Punct} 
	T_69  // \\p{P} 
	T_70  // \\p{Quotation_Mark} 
	T_71  // \\p{Radical} 
	T_72  // \\p{Regional_Indicator} 
	T_73  // \\p{STerm} 
	T_74  // \\p{Sc} 
	T_75  // \\p{Sentence_Terminal} 
	T_76  // \\p{Sk} 
	T_77  // \\p{Sm} 
	T_78  // \\p{Soft_Dotted} 
	T_79  // \\p{So} 
	T_80  // \\p{Space} 
	T_81  // \\p{Symbol} 
	T_82  // \\p{S} 
	T_83  // \\p{Terminal_Punctuation} 
	T_84  // \\p{Title} 
	T_85  // \\p{Unified_Ideograph} 
	T_86  // \\p{Upper} 
	T_87  // \\p{Variation_Selector} 
	T_88  // \\p{White_Space} 
	T_89  // \\p{Zl} 
	T_90  // \\p{Zp} 
	T_91  // \\p{Zs} 
	T_92  // \\p{Z} 
	T_93  // ] 
	T_94  // ]' 
	T_95  // any 
	T_96  // char_lit 
	T_97  // empty 
	T_98  // letter 
	T_99  // lowcase 
	T_100  // not 
	T_101  // nt 
	T_102  // number 
	T_103  // package 
	T_104  // string_lit 
	T_105  // tokid 
	T_106  // upcase 
	T_107  // { 
	T_108  // | 
	T_109  // } 
)

type Symbols []Symbol

func (ss Symbols) Equal(ss1 Symbols) bool {
	if len(ss) != len(ss1) {
		return false
	}
	for i, s := range ss {
		if s.String() != ss1[i].String() {
			return false
		}
	}
	return true
}

func (ss Symbols) String() string {
	w := new(bytes.Buffer)
	for i, s := range ss {
		if i > 0 {
			fmt.Fprint(w, " ")
		}
		fmt.Fprintf(w, "%s", s)
	}
	return w.String()
}

func (ss Symbols) Strings() []string {
	strs := make([]string, len(ss))
	for i, s := range ss {
		strs[i] = s.String()
	}
	return strs
}

func (NT) IsNonTerminal() bool {
	return true
}

func (T) IsNonTerminal() bool {
	return false
}

func (nt NT) String() string {
	return ntToString[nt]
}

func (t T) String() string {
	return tToString[t]
}

// IsNT returns true iff sym is a non-terminal symbol of the grammar
func IsNT(sym string) bool {
	_, exist := stringNT[sym]
	return exist
}

// ToNT returns the NT value of sym or panics if sym is not a non-terminal of the grammar
func ToNT(sym string) NT {
	nt, exist := stringNT[sym]
	if !exist {
		panic(fmt.Sprintf("No NT: %s", sym))
	}
	return nt
}

var ntToString = []string { 
	"GoGLL", /* NT_GoGLL */
	"LexAlternates", /* NT_LexAlternates */
	"LexBracket", /* NT_LexBracket */
	"LexGroup", /* NT_LexGroup */
	"LexOneOrMore", /* NT_LexOneOrMore */
	"LexOptional", /* NT_LexOptional */
	"LexRule", /* NT_LexRule */
	"LexSymbol", /* NT_LexSymbol */
	"LexZeroOrMore", /* NT_LexZeroOrMore */
	"Package", /* NT_Package */
	"PlusOrMinUnicodeSet", /* NT_PlusOrMinUnicodeSet */
	"RegExp", /* NT_RegExp */
	"Rule", /* NT_Rule */
	"Rules", /* NT_Rules */
	"SyntaxAlternate", /* NT_SyntaxAlternate */
	"SyntaxAlternates", /* NT_SyntaxAlternates */
	"SyntaxRule", /* NT_SyntaxRule */
	"SyntaxSymbol", /* NT_SyntaxSymbol */
	"SyntaxSymbols", /* NT_SyntaxSymbols */
	"UnicodeCategory", /* NT_UnicodeCategory */
	"UnicodeClass", /* NT_UnicodeClass */
	"UnicodeProperty", /* NT_UnicodeProperty */
	"UnicodeSet", /* NT_UnicodeSet */
	"UnicodeSetSpec", /* NT_UnicodeSetSpec */
	"UnicodeSetSpecs", /* NT_UnicodeSetSpecs */
	"UnicodeSpecList", /* NT_UnicodeSpecList */ 
}

var tToString = []string { 
	"!", /* T_0 */
	"'[", /* T_1 */
	"(", /* T_2 */
	")", /* T_3 */
	"-", /* T_4 */
	".", /* T_5 */
	":", /* T_6 */
	";", /* T_7 */
	"<", /* T_8 */
	">", /* T_9 */
	"[", /* T_10 */
	"\\p{ASCII_Hex_Digit}", /* T_11 */
	"\\p{Bidi_Control}", /* T_12 */
	"\\p{Cc}", /* T_13 */
	"\\p{Cf}", /* T_14 */
	"\\p{Co}", /* T_15 */
	"\\p{Cs}", /* T_16 */
	"\\p{C}", /* T_17 */
	"\\p{Dash}", /* T_18 */
	"\\p{Deprecated}", /* T_19 */
	"\\p{Diacritic}", /* T_20 */
	"\\p{Digit}", /* T_21 */
	"\\p{Extender}", /* T_22 */
	"\\p{Hex_Digit}", /* T_23 */
	"\\p{Hyphen}", /* T_24 */
	"\\p{IDS_Binary_Operator}", /* T_25 */
	"\\p{IDS_Trinary_Operator}", /* T_26 */
	"\\p{Ideographic}", /* T_27 */
	"\\p{Join_Control}", /* T_28 */
	"\\p{Letter}", /* T_29 */
	"\\p{Ll}", /* T_30 */
	"\\p{Lm}", /* T_31 */
	"\\p{Logical_Order_Exception}", /* T_32 */
	"\\p{Lower}", /* T_33 */
	"\\p{Lo}", /* T_34 */
	"\\p{Lt}", /* T_35 */
	"\\p{Lu}", /* T_36 */
	"\\p{L}", /* T_37 */
	"\\p{Mark}", /* T_38 */
	"\\p{Mc}", /* T_39 */
	"\\p{Me}", /* T_40 */
	"\\p{Mn}", /* T_41 */
	"\\p{M}", /* T_42 */
	"\\p{Nd}", /* T_43 */
	"\\p{Nl}", /* T_44 */
	"\\p{Noncharacter_Code_Point}", /* T_45 */
	"\\p{No}", /* T_46 */
	"\\p{Number}", /* T_47 */
	"\\p{N}", /* T_48 */
	"\\p{Other_Alphabetic}", /* T_49 */
	"\\p{Other_Default_Ignorable_Code_Point}", /* T_50 */
	"\\p{Other_Grapheme_Extend}", /* T_51 */
	"\\p{Other_ID_Continue}", /* T_52 */
	"\\p{Other_ID_Start}", /* T_53 */
	"\\p{Other_Lowercase}", /* T_54 */
	"\\p{Other_Math}", /* T_55 */
	"\\p{Other_Uppercase}", /* T_56 */
	"\\p{Other}", /* T_57 */
	"\\p{Pattern_Syntax}", /* T_58 */
	"\\p{Pattern_White_Space}", /* T_59 */
	"\\p{Pc}", /* T_60 */
	"\\p{Pd}", /* T_61 */
	"\\p{Pe}", /* T_62 */
	"\\p{Pf}", /* T_63 */
	"\\p{Pi}", /* T_64 */
	"\\p{Po}", /* T_65 */
	"\\p{Prepended_Concatenation_Mark}", /* T_66 */
	"\\p{Ps}", /* T_67 */
	"\\p{Punct}", /* T_68 */
	"\\p{P}", /* T_69 */
	"\\p{Quotation_Mark}", /* T_70 */
	"\\p{Radical}", /* T_71 */
	"\\p{Regional_Indicator}", /* T_72 */
	"\\p{STerm}", /* T_73 */
	"\\p{Sc}", /* T_74 */
	"\\p{Sentence_Terminal}", /* T_75 */
	"\\p{Sk}", /* T_76 */
	"\\p{Sm}", /* T_77 */
	"\\p{Soft_Dotted}", /* T_78 */
	"\\p{So}", /* T_79 */
	"\\p{Space}", /* T_80 */
	"\\p{Symbol}", /* T_81 */
	"\\p{S}", /* T_82 */
	"\\p{Terminal_Punctuation}", /* T_83 */
	"\\p{Title}", /* T_84 */
	"\\p{Unified_Ideograph}", /* T_85 */
	"\\p{Upper}", /* T_86 */
	"\\p{Variation_Selector}", /* T_87 */
	"\\p{White_Space}", /* T_88 */
	"\\p{Zl}", /* T_89 */
	"\\p{Zp}", /* T_90 */
	"\\p{Zs}", /* T_91 */
	"\\p{Z}", /* T_92 */
	"]", /* T_93 */
	"]'", /* T_94 */
	"any", /* T_95 */
	"char_lit", /* T_96 */
	"empty", /* T_97 */
	"letter", /* T_98 */
	"lowcase", /* T_99 */
	"not", /* T_100 */
	"nt", /* T_101 */
	"number", /* T_102 */
	"package", /* T_103 */
	"string_lit", /* T_104 */
	"tokid", /* T_105 */
	"upcase", /* T_106 */
	"{", /* T_107 */
	"|", /* T_108 */
	"}", /* T_109 */ 
}

var stringNT = map[string]NT{ 
	"GoGLL":NT_GoGLL,
	"LexAlternates":NT_LexAlternates,
	"LexBracket":NT_LexBracket,
	"LexGroup":NT_LexGroup,
	"LexOneOrMore":NT_LexOneOrMore,
	"LexOptional":NT_LexOptional,
	"LexRule":NT_LexRule,
	"LexSymbol":NT_LexSymbol,
	"LexZeroOrMore":NT_LexZeroOrMore,
	"Package":NT_Package,
	"PlusOrMinUnicodeSet":NT_PlusOrMinUnicodeSet,
	"RegExp":NT_RegExp,
	"Rule":NT_Rule,
	"Rules":NT_Rules,
	"SyntaxAlternate":NT_SyntaxAlternate,
	"SyntaxAlternates":NT_SyntaxAlternates,
	"SyntaxRule":NT_SyntaxRule,
	"SyntaxSymbol":NT_SyntaxSymbol,
	"SyntaxSymbols":NT_SyntaxSymbols,
	"UnicodeCategory":NT_UnicodeCategory,
	"UnicodeClass":NT_UnicodeClass,
	"UnicodeProperty":NT_UnicodeProperty,
	"UnicodeSet":NT_UnicodeSet,
	"UnicodeSetSpec":NT_UnicodeSetSpec,
	"UnicodeSetSpecs":NT_UnicodeSetSpecs,
	"UnicodeSpecList":NT_UnicodeSpecList,
}
