
// Package token is generated by GoGLL. Do not edit
package token

import(
    "fmt"
)

// Token is returned by the lexer for every scanned lexical token
type Token struct {
    typ        Type
    lext, rext int
    input      []rune
}

/*
New returns a new token.
lext is the left extent and rext the right extent of the token in the input.
input is the input slice scanned by the lexer.
*/
func New(t Type, lext, rext int, input []rune) *Token {
    return &Token{
        typ:   t,
        lext:  lext,
        rext:  rext,
        input: input,
    }
}

// GetLineColumn returns the line and column of the left extent of t
func (t *Token) GetLineColumn() (line, col int) {
    line, col = 1, 1
    for j := 0; j < t.lext; j++ {
        switch t.input[j] {
        case '\n':
            line++
            col = 1
        case '\t':
            col += 4
        default:
            col++
        }
    }
    return
}

// GetInput returns the input from which t was parsed.
func (t *Token) GetInput() []rune {
    return t.input
}

// Lext returns the left extent of t
func (t *Token) Lext() int {
    return t.lext
}

// Literal returns the literal runes of t scanned by the lexer
func (t *Token) Literal() []rune {
    return t.input[t.lext:t.rext]
}

// LiteralString returns string(t.Literal())
func (t *Token) LiteralString() string {
    return string(t.Literal())
}

// LiteralStripEscape returns the literal runes of t scanned by the lexer
func (t *Token) LiteralStripEscape() []rune {
	lit := t.Literal()
	strip := make([]rune, 0, len(lit))
	for i := 0; i < len(lit); i++ {
		if lit[i] == '\\' {
			i++
			switch lit[i] {
			case 't':
				strip = append(strip, '\t')
			case 'r':
				strip = append(strip, '\r')
			case 'n':
				strip = append(strip, '\r')
			default:
				strip = append(strip, lit[i])
			}
		} else {
			strip = append(strip, lit[i])
		}
	}
	return strip
}

// LiteralStringStripEscape returns string(t.LiteralStripEscape())
func (t *Token) LiteralStringStripEscape() string {
	return string(t.LiteralStripEscape())
}

// Rext returns the right extent of t in the input
func (t *Token) Rext() int {
    return t.rext
}

func (t *Token) String() string {
    return fmt.Sprintf("%s (%d,%d) %s",
        t.TypeID(), t.lext, t.rext, t.LiteralString())
}

// Suppress returns true iff t is suppressed by the lexer
func (t *Token) Suppress() bool {
	return Suppress[t.typ]
}

// Type returns the token Type of t
func (t *Token) Type() Type {
    return t.typ
}

// TypeID returns the token Type ID of t. 
// This may be different from the literal of token t.
func (t *Token) TypeID() string {
    return t.Type().ID()
}

// Type is the token type
type Type int

func (t Type) String() string {
    return TypeToString[t]
}

// ID returns the token type ID of token Type t
func (t Type) ID() string {
    return TypeToID[t]
}


const(
    Error  Type = iota  // Error 
    EOF  // $ 
    T_0  // ! 
    T_1  // '[ 
    T_2  // ( 
    T_3  // ) 
    T_4  // - 
    T_5  // . 
    T_6  // : 
    T_7  // ; 
    T_8  // < 
    T_9  // > 
    T_10  // [ 
    T_11  // \\p{ASCII_Hex_Digit} 
    T_12  // \\p{Bidi_Control} 
    T_13  // \\p{Cc} 
    T_14  // \\p{Cf} 
    T_15  // \\p{Co} 
    T_16  // \\p{Cs} 
    T_17  // \\p{C} 
    T_18  // \\p{Dash} 
    T_19  // \\p{Deprecated} 
    T_20  // \\p{Diacritic} 
    T_21  // \\p{Digit} 
    T_22  // \\p{Extender} 
    T_23  // \\p{Hex_Digit} 
    T_24  // \\p{Hyphen} 
    T_25  // \\p{IDS_Binary_Operator} 
    T_26  // \\p{IDS_Trinary_Operator} 
    T_27  // \\p{Ideographic} 
    T_28  // \\p{Join_Control} 
    T_29  // \\p{Letter} 
    T_30  // \\p{Ll} 
    T_31  // \\p{Lm} 
    T_32  // \\p{Logical_Order_Exception} 
    T_33  // \\p{Lower} 
    T_34  // \\p{Lo} 
    T_35  // \\p{Lt} 
    T_36  // \\p{Lu} 
    T_37  // \\p{L} 
    T_38  // \\p{Mark} 
    T_39  // \\p{Mc} 
    T_40  // \\p{Me} 
    T_41  // \\p{Mn} 
    T_42  // \\p{M} 
    T_43  // \\p{Nd} 
    T_44  // \\p{Nl} 
    T_45  // \\p{Noncharacter_Code_Point} 
    T_46  // \\p{No} 
    T_47  // \\p{Number} 
    T_48  // \\p{N} 
    T_49  // \\p{Other_Alphabetic} 
    T_50  // \\p{Other_Default_Ignorable_Code_Point} 
    T_51  // \\p{Other_Grapheme_Extend} 
    T_52  // \\p{Other_ID_Continue} 
    T_53  // \\p{Other_ID_Start} 
    T_54  // \\p{Other_Lowercase} 
    T_55  // \\p{Other_Math} 
    T_56  // \\p{Other_Uppercase} 
    T_57  // \\p{Other} 
    T_58  // \\p{Pattern_Syntax} 
    T_59  // \\p{Pattern_White_Space} 
    T_60  // \\p{Pc} 
    T_61  // \\p{Pd} 
    T_62  // \\p{Pe} 
    T_63  // \\p{Pf} 
    T_64  // \\p{Pi} 
    T_65  // \\p{Po} 
    T_66  // \\p{Prepended_Concatenation_Mark} 
    T_67  // \\p{Ps} 
    T_68  // \\p{Punct} 
    T_69  // \\p{P} 
    T_70  // \\p{Quotation_Mark} 
    T_71  // \\p{Radical} 
    T_72  // \\p{Regional_Indicator} 
    T_73  // \\p{STerm} 
    T_74  // \\p{Sc} 
    T_75  // \\p{Sentence_Terminal} 
    T_76  // \\p{Sk} 
    T_77  // \\p{Sm} 
    T_78  // \\p{Soft_Dotted} 
    T_79  // \\p{So} 
    T_80  // \\p{Space} 
    T_81  // \\p{Symbol} 
    T_82  // \\p{S} 
    T_83  // \\p{Terminal_Punctuation} 
    T_84  // \\p{Title} 
    T_85  // \\p{Unified_Ideograph} 
    T_86  // \\p{Upper} 
    T_87  // \\p{Variation_Selector} 
    T_88  // \\p{White_Space} 
    T_89  // \\p{Zl} 
    T_90  // \\p{Zp} 
    T_91  // \\p{Zs} 
    T_92  // \\p{Z} 
    T_93  // ] 
    T_94  // ]' 
    T_95  // any 
    T_96  // char_lit 
    T_97  // empty 
    T_98  // letter 
    T_99  // lowcase 
    T_100  // not 
    T_101  // nt 
    T_102  // number 
    T_103  // package 
    T_104  // string_lit 
    T_105  // tokid 
    T_106  // upcase 
    T_107  // { 
    T_108  // | 
    T_109  // } 
)

var TypeToString = []string{ 
    "Error",
    "EOF",
    "T_0",
    "T_1",
    "T_2",
    "T_3",
    "T_4",
    "T_5",
    "T_6",
    "T_7",
    "T_8",
    "T_9",
    "T_10",
    "T_11",
    "T_12",
    "T_13",
    "T_14",
    "T_15",
    "T_16",
    "T_17",
    "T_18",
    "T_19",
    "T_20",
    "T_21",
    "T_22",
    "T_23",
    "T_24",
    "T_25",
    "T_26",
    "T_27",
    "T_28",
    "T_29",
    "T_30",
    "T_31",
    "T_32",
    "T_33",
    "T_34",
    "T_35",
    "T_36",
    "T_37",
    "T_38",
    "T_39",
    "T_40",
    "T_41",
    "T_42",
    "T_43",
    "T_44",
    "T_45",
    "T_46",
    "T_47",
    "T_48",
    "T_49",
    "T_50",
    "T_51",
    "T_52",
    "T_53",
    "T_54",
    "T_55",
    "T_56",
    "T_57",
    "T_58",
    "T_59",
    "T_60",
    "T_61",
    "T_62",
    "T_63",
    "T_64",
    "T_65",
    "T_66",
    "T_67",
    "T_68",
    "T_69",
    "T_70",
    "T_71",
    "T_72",
    "T_73",
    "T_74",
    "T_75",
    "T_76",
    "T_77",
    "T_78",
    "T_79",
    "T_80",
    "T_81",
    "T_82",
    "T_83",
    "T_84",
    "T_85",
    "T_86",
    "T_87",
    "T_88",
    "T_89",
    "T_90",
    "T_91",
    "T_92",
    "T_93",
    "T_94",
    "T_95",
    "T_96",
    "T_97",
    "T_98",
    "T_99",
    "T_100",
    "T_101",
    "T_102",
    "T_103",
    "T_104",
    "T_105",
    "T_106",
    "T_107",
    "T_108",
    "T_109",
}

var StringToType = map[string] Type { 
    "Error" : Error, 
    "EOF" : EOF, 
    "T_0" : T_0, 
    "T_1" : T_1, 
    "T_2" : T_2, 
    "T_3" : T_3, 
    "T_4" : T_4, 
    "T_5" : T_5, 
    "T_6" : T_6, 
    "T_7" : T_7, 
    "T_8" : T_8, 
    "T_9" : T_9, 
    "T_10" : T_10, 
    "T_11" : T_11, 
    "T_12" : T_12, 
    "T_13" : T_13, 
    "T_14" : T_14, 
    "T_15" : T_15, 
    "T_16" : T_16, 
    "T_17" : T_17, 
    "T_18" : T_18, 
    "T_19" : T_19, 
    "T_20" : T_20, 
    "T_21" : T_21, 
    "T_22" : T_22, 
    "T_23" : T_23, 
    "T_24" : T_24, 
    "T_25" : T_25, 
    "T_26" : T_26, 
    "T_27" : T_27, 
    "T_28" : T_28, 
    "T_29" : T_29, 
    "T_30" : T_30, 
    "T_31" : T_31, 
    "T_32" : T_32, 
    "T_33" : T_33, 
    "T_34" : T_34, 
    "T_35" : T_35, 
    "T_36" : T_36, 
    "T_37" : T_37, 
    "T_38" : T_38, 
    "T_39" : T_39, 
    "T_40" : T_40, 
    "T_41" : T_41, 
    "T_42" : T_42, 
    "T_43" : T_43, 
    "T_44" : T_44, 
    "T_45" : T_45, 
    "T_46" : T_46, 
    "T_47" : T_47, 
    "T_48" : T_48, 
    "T_49" : T_49, 
    "T_50" : T_50, 
    "T_51" : T_51, 
    "T_52" : T_52, 
    "T_53" : T_53, 
    "T_54" : T_54, 
    "T_55" : T_55, 
    "T_56" : T_56, 
    "T_57" : T_57, 
    "T_58" : T_58, 
    "T_59" : T_59, 
    "T_60" : T_60, 
    "T_61" : T_61, 
    "T_62" : T_62, 
    "T_63" : T_63, 
    "T_64" : T_64, 
    "T_65" : T_65, 
    "T_66" : T_66, 
    "T_67" : T_67, 
    "T_68" : T_68, 
    "T_69" : T_69, 
    "T_70" : T_70, 
    "T_71" : T_71, 
    "T_72" : T_72, 
    "T_73" : T_73, 
    "T_74" : T_74, 
    "T_75" : T_75, 
    "T_76" : T_76, 
    "T_77" : T_77, 
    "T_78" : T_78, 
    "T_79" : T_79, 
    "T_80" : T_80, 
    "T_81" : T_81, 
    "T_82" : T_82, 
    "T_83" : T_83, 
    "T_84" : T_84, 
    "T_85" : T_85, 
    "T_86" : T_86, 
    "T_87" : T_87, 
    "T_88" : T_88, 
    "T_89" : T_89, 
    "T_90" : T_90, 
    "T_91" : T_91, 
    "T_92" : T_92, 
    "T_93" : T_93, 
    "T_94" : T_94, 
    "T_95" : T_95, 
    "T_96" : T_96, 
    "T_97" : T_97, 
    "T_98" : T_98, 
    "T_99" : T_99, 
    "T_100" : T_100, 
    "T_101" : T_101, 
    "T_102" : T_102, 
    "T_103" : T_103, 
    "T_104" : T_104, 
    "T_105" : T_105, 
    "T_106" : T_106, 
    "T_107" : T_107, 
    "T_108" : T_108, 
    "T_109" : T_109, 
}

var TypeToID = []string { 
    "Error", 
    "$", 
    "!", 
    "'[", 
    "(", 
    ")", 
    "-", 
    ".", 
    ":", 
    ";", 
    "<", 
    ">", 
    "[", 
    "\\p{ASCII_Hex_Digit}", 
    "\\p{Bidi_Control}", 
    "\\p{Cc}", 
    "\\p{Cf}", 
    "\\p{Co}", 
    "\\p{Cs}", 
    "\\p{C}", 
    "\\p{Dash}", 
    "\\p{Deprecated}", 
    "\\p{Diacritic}", 
    "\\p{Digit}", 
    "\\p{Extender}", 
    "\\p{Hex_Digit}", 
    "\\p{Hyphen}", 
    "\\p{IDS_Binary_Operator}", 
    "\\p{IDS_Trinary_Operator}", 
    "\\p{Ideographic}", 
    "\\p{Join_Control}", 
    "\\p{Letter}", 
    "\\p{Ll}", 
    "\\p{Lm}", 
    "\\p{Logical_Order_Exception}", 
    "\\p{Lower}", 
    "\\p{Lo}", 
    "\\p{Lt}", 
    "\\p{Lu}", 
    "\\p{L}", 
    "\\p{Mark}", 
    "\\p{Mc}", 
    "\\p{Me}", 
    "\\p{Mn}", 
    "\\p{M}", 
    "\\p{Nd}", 
    "\\p{Nl}", 
    "\\p{Noncharacter_Code_Point}", 
    "\\p{No}", 
    "\\p{Number}", 
    "\\p{N}", 
    "\\p{Other_Alphabetic}", 
    "\\p{Other_Default_Ignorable_Code_Point}", 
    "\\p{Other_Grapheme_Extend}", 
    "\\p{Other_ID_Continue}", 
    "\\p{Other_ID_Start}", 
    "\\p{Other_Lowercase}", 
    "\\p{Other_Math}", 
    "\\p{Other_Uppercase}", 
    "\\p{Other}", 
    "\\p{Pattern_Syntax}", 
    "\\p{Pattern_White_Space}", 
    "\\p{Pc}", 
    "\\p{Pd}", 
    "\\p{Pe}", 
    "\\p{Pf}", 
    "\\p{Pi}", 
    "\\p{Po}", 
    "\\p{Prepended_Concatenation_Mark}", 
    "\\p{Ps}", 
    "\\p{Punct}", 
    "\\p{P}", 
    "\\p{Quotation_Mark}", 
    "\\p{Radical}", 
    "\\p{Regional_Indicator}", 
    "\\p{STerm}", 
    "\\p{Sc}", 
    "\\p{Sentence_Terminal}", 
    "\\p{Sk}", 
    "\\p{Sm}", 
    "\\p{Soft_Dotted}", 
    "\\p{So}", 
    "\\p{Space}", 
    "\\p{Symbol}", 
    "\\p{S}", 
    "\\p{Terminal_Punctuation}", 
    "\\p{Title}", 
    "\\p{Unified_Ideograph}", 
    "\\p{Upper}", 
    "\\p{Variation_Selector}", 
    "\\p{White_Space}", 
    "\\p{Zl}", 
    "\\p{Zp}", 
    "\\p{Zs}", 
    "\\p{Z}", 
    "]", 
    "]'", 
    "any", 
    "char_lit", 
    "empty", 
    "letter", 
    "lowcase", 
    "not", 
    "nt", 
    "number", 
    "package", 
    "string_lit", 
    "tokid", 
    "upcase", 
    "{", 
    "|", 
    "}", 
}

var IDToType = map[string]Type { 
    "Error": 0, 
    "$": 1, 
    "!": 2, 
    "'[": 3, 
    "(": 4, 
    ")": 5, 
    "-": 6, 
    ".": 7, 
    ":": 8, 
    ";": 9, 
    "<": 10, 
    ">": 11, 
    "[": 12, 
    "\\p{ASCII_Hex_Digit}": 13, 
    "\\p{Bidi_Control}": 14, 
    "\\p{Cc}": 15, 
    "\\p{Cf}": 16, 
    "\\p{Co}": 17, 
    "\\p{Cs}": 18, 
    "\\p{C}": 19, 
    "\\p{Dash}": 20, 
    "\\p{Deprecated}": 21, 
    "\\p{Diacritic}": 22, 
    "\\p{Digit}": 23, 
    "\\p{Extender}": 24, 
    "\\p{Hex_Digit}": 25, 
    "\\p{Hyphen}": 26, 
    "\\p{IDS_Binary_Operator}": 27, 
    "\\p{IDS_Trinary_Operator}": 28, 
    "\\p{Ideographic}": 29, 
    "\\p{Join_Control}": 30, 
    "\\p{Letter}": 31, 
    "\\p{Ll}": 32, 
    "\\p{Lm}": 33, 
    "\\p{Logical_Order_Exception}": 34, 
    "\\p{Lower}": 35, 
    "\\p{Lo}": 36, 
    "\\p{Lt}": 37, 
    "\\p{Lu}": 38, 
    "\\p{L}": 39, 
    "\\p{Mark}": 40, 
    "\\p{Mc}": 41, 
    "\\p{Me}": 42, 
    "\\p{Mn}": 43, 
    "\\p{M}": 44, 
    "\\p{Nd}": 45, 
    "\\p{Nl}": 46, 
    "\\p{Noncharacter_Code_Point}": 47, 
    "\\p{No}": 48, 
    "\\p{Number}": 49, 
    "\\p{N}": 50, 
    "\\p{Other_Alphabetic}": 51, 
    "\\p{Other_Default_Ignorable_Code_Point}": 52, 
    "\\p{Other_Grapheme_Extend}": 53, 
    "\\p{Other_ID_Continue}": 54, 
    "\\p{Other_ID_Start}": 55, 
    "\\p{Other_Lowercase}": 56, 
    "\\p{Other_Math}": 57, 
    "\\p{Other_Uppercase}": 58, 
    "\\p{Other}": 59, 
    "\\p{Pattern_Syntax}": 60, 
    "\\p{Pattern_White_Space}": 61, 
    "\\p{Pc}": 62, 
    "\\p{Pd}": 63, 
    "\\p{Pe}": 64, 
    "\\p{Pf}": 65, 
    "\\p{Pi}": 66, 
    "\\p{Po}": 67, 
    "\\p{Prepended_Concatenation_Mark}": 68, 
    "\\p{Ps}": 69, 
    "\\p{Punct}": 70, 
    "\\p{P}": 71, 
    "\\p{Quotation_Mark}": 72, 
    "\\p{Radical}": 73, 
    "\\p{Regional_Indicator}": 74, 
    "\\p{STerm}": 75, 
    "\\p{Sc}": 76, 
    "\\p{Sentence_Terminal}": 77, 
    "\\p{Sk}": 78, 
    "\\p{Sm}": 79, 
    "\\p{Soft_Dotted}": 80, 
    "\\p{So}": 81, 
    "\\p{Space}": 82, 
    "\\p{Symbol}": 83, 
    "\\p{S}": 84, 
    "\\p{Terminal_Punctuation}": 85, 
    "\\p{Title}": 86, 
    "\\p{Unified_Ideograph}": 87, 
    "\\p{Upper}": 88, 
    "\\p{Variation_Selector}": 89, 
    "\\p{White_Space}": 90, 
    "\\p{Zl}": 91, 
    "\\p{Zp}": 92, 
    "\\p{Zs}": 93, 
    "\\p{Z}": 94, 
    "]": 95, 
    "]'": 96, 
    "any": 97, 
    "char_lit": 98, 
    "empty": 99, 
    "letter": 100, 
    "lowcase": 101, 
    "not": 102, 
    "nt": 103, 
    "number": 104, 
    "package": 105, 
    "string_lit": 106, 
    "tokid": 107, 
    "upcase": 108, 
    "{": 109, 
    "|": 110, 
    "}": 111, 
}

var Suppress = []bool { 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
    false, 
}

